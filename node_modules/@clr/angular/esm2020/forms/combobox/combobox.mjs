/*
 * Copyright (c) 2016-2024 Broadcom. All Rights Reserved.
 * The term "Broadcom" refers to Broadcom Inc. and/or its subsidiaries.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { isPlatformBrowser } from '@angular/common';
import { Component, ContentChild, EventEmitter, HostListener, Inject, Input, Optional, Output, PLATFORM_ID, Self, ViewChild, } from '@angular/core';
import { IF_ACTIVE_ID_PROVIDER } from '../../utils/conditional/if-active.service';
import { Keys } from '../../utils/enums/keys.enum';
import { FOCUS_SERVICE_PROVIDER } from '../../utils/focus/focus.service';
import { ClrLoadingState } from '../../utils/loading/loading';
import { LoadingListener } from '../../utils/loading/loading-listener';
import { ClrAlignment } from '../../utils/popover/enums/alignment.enum';
import { ClrAxis } from '../../utils/popover/enums/axis.enum';
import { ClrSide } from '../../utils/popover/enums/side.enum';
import { ClrPopoverHostDirective } from '../../utils/popover/popover-host.directive';
import { CONTROL_STATE } from '../common/if-control-state/if-control-state.service';
import { WrappedFormControl } from '../common/wrapped-control';
import { ClrComboboxContainer } from './combobox-container';
import { MultiSelectComboboxModel } from './model/multi-select-combobox.model';
import { SingleSelectComboboxModel } from './model/single-select-combobox.model';
import { ClrOptionSelected } from './option-selected.directive';
import { ClrOptions } from './options';
import { COMBOBOX_FOCUS_HANDLER_PROVIDER } from './providers/combobox-focus-handler.service';
import { OptionSelectionService } from './providers/option-selection.service';
import * as i0 from "@angular/core";
import * as i1 from "@angular/forms";
import * as i2 from "./providers/option-selection.service";
import * as i3 from "../../utils/i18n/common-strings.service";
import * as i4 from "../../utils/popover/providers/popover-toggle.service";
import * as i5 from "../../utils/popover/providers/popover-position.service";
import * as i6 from "../common/if-control-state/if-control-state.service";
import * as i7 from "./providers/combobox-container.service";
import * as i8 from "./providers/combobox-focus-handler.service";
import * as i9 from "../../utils/popover/popover-host.directive";
import * as i10 from "@angular/common";
import * as i11 from "../../icon/icon";
import * as i12 from "../../utils/focus/key-focus/roving-tabindex";
import * as i13 from "../../utils/focus/key-focus/key-focus-item";
import * as i14 from "../../utils/popover/popover-anchor";
import * as i15 from "../../utils/popover/popover-open-close-button";
import * as i16 from "../../utils/popover/popover-content";
export class ClrCombobox extends WrappedFormControl {
    constructor(vcr, injector, control, renderer, el, optionSelectionService, commonStrings, toggleService, positionService, controlStateService, containerService, platformId, focusHandler, cdr) {
        super(vcr, ClrComboboxContainer, injector, control, renderer, el);
        this.control = control;
        this.renderer = renderer;
        this.el = el;
        this.optionSelectionService = optionSelectionService;
        this.commonStrings = commonStrings;
        this.toggleService = toggleService;
        this.positionService = positionService;
        this.controlStateService = controlStateService;
        this.containerService = containerService;
        this.platformId = platformId;
        this.focusHandler = focusHandler;
        this.cdr = cdr;
        this.placeholder = '';
        this.clrInputChange = new EventEmitter(false);
        this.clrOpenChange = this.toggleService.openChange;
        /**
         * This output should be used to set up a live region using aria-live and populate it with updates that reflect each combobox change.
         */
        this.clrSelectionChange = this.optionSelectionService.selectionChanged;
        this.invalid = false;
        this.focused = false;
        this.smartPosition = {
            axis: ClrAxis.VERTICAL,
            side: ClrSide.AFTER,
            anchor: ClrAlignment.START,
            content: ClrAlignment.START,
        };
        this.index = 1;
        this._searchText = '';
        if (control) {
            control.valueAccessor = this;
        }
        // default to SingleSelectComboboxModel, in case the optional input [ClrMulti] isn't used
        optionSelectionService.selectionModel = new SingleSelectComboboxModel();
        this.updateControlValue();
    }
    get multiSelect() {
        return this.optionSelectionService.multiselectable;
    }
    set multiSelect(value) {
        if (value) {
            this.optionSelectionService.selectionModel = new MultiSelectComboboxModel();
        }
        else {
            // in theory, setting this again should not cause errors even though we already set it in constructor,
            // since the initial call to writeValue (caused by [ngModel] input) should happen after this
            this.optionSelectionService.selectionModel = new SingleSelectComboboxModel();
        }
        this.updateControlValue();
    }
    // Override the id of WrappedFormControl, as we want to move it to the embedded input.
    // Otherwise the label/component connection does not work and screen readers do not read the label.
    get id() {
        return this.controlIdService.id + '-combobox';
    }
    set id(id) {
        super.id = id;
    }
    get searchText() {
        return this._searchText;
    }
    set searchText(text) {
        // if input text has changed since last time, fire a change event so application can react to it
        if (text !== this._searchText) {
            if (this.toggleService.open) {
                this.optionSelectionService.showAllOptions = false;
            }
            this._searchText = text;
            this.clrInputChange.emit(this.searchText);
        }
        // We need to trigger this even if unchanged, so the option-items directive will update its list
        // based on the "showAllOptions" variable which may have changed in the openChange subscription below.
        // The option-items directive does not listen to openChange, but it listens to currentInput changes.
        this.optionSelectionService.currentInput = this.searchText;
    }
    get openState() {
        return this.toggleService.open;
    }
    get multiSelectModel() {
        if (!this.multiSelect) {
            throw Error('multiSelectModel is not available in single selection context');
        }
        return this.optionSelectionService.selectionModel.model;
    }
    get ariaControls() {
        return this.options?.optionsId;
    }
    get ariaOwns() {
        return this.options?.optionsId;
    }
    get ariaDescribedBySelection() {
        return 'selection-' + this.id;
    }
    get displayField() {
        return this.optionSelectionService.displayField;
    }
    get disabled() {
        return this.control && this.control.disabled;
    }
    ngAfterContentInit() {
        this.initializeSubscriptions();
        // Initialize with preselected value
        if (!this.optionSelectionService.selectionModel.isEmpty()) {
            this.updateInputValue(this.optionSelectionService.selectionModel);
        }
    }
    ngAfterViewInit() {
        this.focusHandler.componentCdRef = this.cdr;
        this.focusHandler.textInput = this.textbox.nativeElement;
        this.focusHandler.trigger = this.trigger.nativeElement;
        // The text input is the actual element we are wrapping
        // This assignment is needed by the wrapper, so it can set
        // the aria properties on the input element, not on the component.
        this.el = this.textbox;
    }
    onKeyUp(event) {
        // if BACKSPACE in multiselect mode, delete the last pill if text is empty
        if (event.key === Keys.Backspace && this.multiSelect && this._searchText.length === 0) {
            const multiModel = this.optionSelectionService.selectionModel.model;
            if (multiModel && multiModel.length > 0) {
                const lastItem = multiModel[multiModel.length - 1];
                this.control.control.markAsTouched();
                this.optionSelectionService.unselect(lastItem);
            }
        }
    }
    inputId() {
        return this.controlIdService.id;
    }
    loadingStateChange(state) {
        this.optionSelectionService.loading = state === ClrLoadingState.LOADING;
        this.positionService.realign();
        if (state !== ClrLoadingState.LOADING && isPlatformBrowser(this.platformId)) {
            this.focusFirstActive();
        }
    }
    unselect(item) {
        if (!this.disabled) {
            this.optionSelectionService.unselect(item);
        }
    }
    onBlur() {
        this.onTouchedCallback();
        if (this.control.control.updateOn === 'change' && this.control.control?.errors?.required) {
            this.updateControlValue();
        }
        if (this.control.control.updateOn === 'blur') {
            this.control.control.updateValueAndValidity();
        }
        this.focused = false;
    }
    onFocus() {
        this.focused = true;
        // fix for "expression changed" error when focus is returned to a combobox after a modal is closed
        // https://github.com/vmware-clarity/ng-clarity/issues/663
        this.cdr.detectChanges();
    }
    getSelectionAriaLabel() {
        if (this.containerService && this.containerService.labelText) {
            return `${this.containerService.labelText} ${this.commonStrings.keys.comboboxSelection}`;
        }
        return this.commonStrings.keys.comboboxSelection;
    }
    focusFirstActive() {
        setTimeout(() => {
            this.focusHandler.focusFirstActive();
        });
    }
    writeValue(value) {
        this.optionSelectionService.selectionModel.model = value;
        this.updateInputValue(this.optionSelectionService.selectionModel);
    }
    registerOnTouched(onTouched) {
        this.onTouchedCallback = onTouched;
    }
    registerOnChange(onChange) {
        this.onChangeCallback = onChange;
    }
    getActiveDescendant() {
        const model = this.focusHandler.pseudoFocus.model;
        return model ? model.id : this.options?.noResultsElementId;
    }
    setDisabledState() {
        // do nothing
    }
    focusInput() {
        this.focusHandler.focusInput();
    }
    initializeSubscriptions() {
        this.subscriptions.push(this.optionSelectionService.selectionChanged.subscribe((newSelection) => {
            this.updateInputValue(newSelection);
            if (this.multiSelect) {
                this.positionService.realign();
            }
            if (!this.multiSelect && newSelection && !newSelection.isEmpty()) {
                this.toggleService.open = false;
            }
            this.updateControlValue();
        }));
        this.subscriptions.push(this.toggleService.openChange.subscribe(open => {
            if (open) {
                this.focusFirstActive();
            }
            else {
                this.optionSelectionService.showAllOptions = true;
            }
            if (this.multiSelect) {
                this.searchText = '';
            }
            else {
                this.searchText = this.getDisplayNames(this.optionSelectionService.selectionModel.model)[0] || '';
            }
        }));
        this.subscriptions.push(this.toggleService.popoverAligned.subscribe(popoverNode => {
            // When used outside a combobox container
            if (!this.containerService) {
                return;
            }
            const popover = popoverNode;
            // Update position if popover hides the label
            if (popover.getBoundingClientRect().top < this.el.nativeElement.getBoundingClientRect().top) {
                this.renderer.setStyle(popoverNode, 'top', `${popover.offsetTop + this.containerService.labelOffset}px`);
            }
        }));
        if (this.controlStateService) {
            this.subscriptions.push(this.controlStateService.statusChanges.subscribe(invalid => {
                this.invalid = this.control.control.touched && invalid === CONTROL_STATE.INVALID;
            }));
        }
    }
    updateInputValue(model) {
        if (!this.multiSelect) {
            this.searchText = model.model ? this.getDisplayNames(model.model)[0] : '';
            if (this.searchText) {
                this.optionSelectionService.currentInput = this.searchText;
            }
        }
    }
    updateControlValue() {
        if (this.onChangeCallback) {
            this.onChangeCallback(this.optionSelectionService.selectionModel.model);
        }
    }
    getDisplayNames(model) {
        if (this.displayField) {
            if (!Array.isArray(model)) {
                model = [model];
            }
            return model.map(item => (item ? item[this.displayField] : null));
        }
        return [this.optionSelectionService.selectionModel.model];
    }
}
ClrCombobox.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: ClrCombobox, deps: [{ token: i0.ViewContainerRef }, { token: i0.Injector }, { token: i1.NgControl, optional: true, self: true }, { token: i0.Renderer2 }, { token: i0.ElementRef }, { token: i2.OptionSelectionService }, { token: i3.ClrCommonStringsService }, { token: i4.ClrPopoverToggleService }, { token: i5.ClrPopoverPositionService }, { token: i6.IfControlStateService, optional: true }, { token: i7.ComboboxContainerService, optional: true }, { token: PLATFORM_ID }, { token: i8.ComboboxFocusHandler }, { token: i0.ChangeDetectorRef }], target: i0.ɵɵFactoryTarget.Component });
ClrCombobox.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "15.2.2", type: ClrCombobox, selector: "clr-combobox", inputs: { placeholder: "placeholder", multiSelect: ["clrMulti", "multiSelect"] }, outputs: { clrInputChange: "clrInputChange", clrOpenChange: "clrOpenChange", clrSelectionChange: "clrSelectionChange" }, host: { listeners: { "keydown": "onKeyUp($event)" }, properties: { "class.aria-required": "true", "class.clr-combobox": "true", "class.clr-combobox-disabled": "control?.disabled" } }, providers: [
        OptionSelectionService,
        { provide: LoadingListener, useExisting: ClrCombobox },
        IF_ACTIVE_ID_PROVIDER,
        FOCUS_SERVICE_PROVIDER,
        COMBOBOX_FOCUS_HANDLER_PROVIDER,
    ], queries: [{ propertyName: "optionSelected", first: true, predicate: ClrOptionSelected, descendants: true }, { propertyName: "options", first: true, predicate: ClrOptions, descendants: true }], viewQueries: [{ propertyName: "textbox", first: true, predicate: ["textboxInput"], descendants: true }, { propertyName: "trigger", first: true, predicate: ["trigger"], descendants: true }], usesInheritance: true, hostDirectives: [{ directive: i9.ClrPopoverHostDirective }], ngImport: i0, template: "<!--\n  ~ Copyright (c) 2016-2024 Broadcom. All Rights Reserved.\n  ~ The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n-->\n\n<!-- The (click) handler is needed to auto-focus on input field which can not currently occupy the whole\n     width of the component, after being wrapped to a new line -->\n<div\n  class=\"clr-combobox-wrapper\"\n  clrPopoverAnchor\n  (click)=\"focusInput()\"\n  [class.multi]=\"multiSelect\"\n  [class.invalid]=\"invalid\"\n  [class.disabled]=\"control?.disabled? true: null\"\n>\n  <span\n    *ngIf=\"multiSelect && optionSelectionService.selectionModel.model\"\n    role=\"grid\"\n    clrRovingTabindex\n    [clrRovingTabindexDisabled]=\"control?.disabled\"\n    clrDirection=\"both\"\n    [attr.aria-label]=\"getSelectionAriaLabel()\"\n    [attr.aria-disabled]=\"control?.disabled? true: null\"\n  >\n    <span *ngFor=\"let item of multiSelectModel; let i = index\" class=\"label label-combobox-pill\" role=\"row\">\n      <span role=\"gridcell\">\n        <span class=\"clr-combobox-pill-content\" clrKeyFocusItem>\n          <ng-container\n            *ngIf=\"optionSelected\"\n            [ngTemplateOutlet]=\"optionSelected.template\"\n            [ngTemplateOutletContext]=\"{$implicit: optionSelectionService.selectionModel.model[i]}\"\n          ></ng-container>\n        </span>\n      </span>\n      <span role=\"gridcell\">\n        <button\n          clrKeyFocusItem\n          type=\"button\"\n          class=\"clr-combobox-remove-btn\"\n          [disabled]=\"control?.disabled? true: null\"\n          [attr.aria-label]=\"commonStrings.keys.comboboxDelete + ' ' + optionSelectionService.selectionModel.toString(displayField, i)\"\n          (click)=\"unselect(item)\"\n        >\n          <cds-icon shape=\"window-close\" size=\"12\"></cds-icon>\n        </button>\n      </span>\n    </span>\n  </span>\n\n  <span class=\"clr-combobox-input-wrapper\">\n    <input\n      #textboxInput\n      type=\"text\"\n      role=\"combobox\"\n      [id]=\"inputId()\"\n      class=\"clr-input clr-combobox-input\"\n      [(ngModel)]=\"searchText\"\n      (blur)=\"onBlur()\"\n      (focus)=\"onFocus()\"\n      [attr.aria-expanded]=\"openState\"\n      [attr.aria-owns]=\"ariaOwns\"\n      aria-haspopup=\"listbox\"\n      aria-autocomplete=\"list\"\n      autocomplete=\"off\"\n      [attr.aria-invalid]=\"control?.invalid? true: null\"\n      [disabled]=\"control?.disabled? true: null\"\n      [attr.aria-activedescendant]=\"getActiveDescendant()\"\n      [attr.placeholder]=\"placeholder\"\n    />\n  </span>\n\n  <!-- No click handler, as it uses the handler on the .clr-combobox-wrapper -->\n  <button\n    clrPopoverOpenCloseButton\n    #trigger\n    type=\"button\"\n    class=\"clr-combobox-trigger\"\n    tabindex=\"-1\"\n    [disabled]=\"control?.disabled || null\"\n    [attr.aria-label]=\"commonStrings.keys.comboboxOpen\"\n  >\n    <cds-icon shape=\"angle\" direction=\"down\"></cds-icon>\n  </button>\n\n  <div class=\"clr-focus-indicator\" [class.clr-focus]=\"focused\"></div>\n</div>\n\n<!-- Both close handlers are handled manually due to issues in Edge browser.\n     Additionally 'outsideClickToClose' has complex handling that's necessary\n     to be manual due to the component architecture -->\n<div role=\"dialog\" *clrPopoverContent=\"openState at smartPosition; outsideClickToClose: false; scrollToClose: false\">\n  <ng-content></ng-content>\n</div>\n", dependencies: [{ kind: "directive", type: i10.NgForOf, selector: "[ngFor][ngForOf]", inputs: ["ngForOf", "ngForTrackBy", "ngForTemplate"] }, { kind: "directive", type: i10.NgIf, selector: "[ngIf]", inputs: ["ngIf", "ngIfThen", "ngIfElse"] }, { kind: "directive", type: i10.NgTemplateOutlet, selector: "[ngTemplateOutlet]", inputs: ["ngTemplateOutletContext", "ngTemplateOutlet", "ngTemplateOutletInjector"] }, { kind: "directive", type: i1.DefaultValueAccessor, selector: "input:not([type=checkbox])[formControlName],textarea[formControlName],input:not([type=checkbox])[formControl],textarea[formControl],input:not([type=checkbox])[ngModel],textarea[ngModel],[ngDefaultControl]" }, { kind: "directive", type: i1.NgControlStatus, selector: "[formControlName],[ngModel],[formControl]" }, { kind: "directive", type: i1.NgModel, selector: "[ngModel]:not([formControlName]):not([formControl])", inputs: ["name", "disabled", "ngModel", "ngModelOptions"], outputs: ["ngModelChange"], exportAs: ["ngModel"] }, { kind: "directive", type: i11.CdsIconCustomTag, selector: "cds-icon" }, { kind: "component", type: i12.ClrRovingTabindex, selector: "[clrRovingTabindex]", inputs: ["clrRovingTabindex", "clrRovingTabindexDisabled"] }, { kind: "directive", type: i13.ClrKeyFocusItem, selector: "[clrKeyFocusItem]" }, { kind: "directive", type: i14.ClrPopoverAnchor, selector: "[clrPopoverAnchor]" }, { kind: "directive", type: i15.ClrPopoverOpenCloseButton, selector: "[clrPopoverOpenCloseButton]", outputs: ["clrPopoverOpenCloseChange"] }, { kind: "directive", type: i16.ClrPopoverContent, selector: "[clrPopoverContent]", inputs: ["clrPopoverContent", "clrPopoverContentAt", "clrPopoverContentOutsideClickToClose", "clrPopoverContentScrollToClose"] }] });
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "15.2.2", ngImport: i0, type: ClrCombobox, decorators: [{
            type: Component,
            args: [{ selector: 'clr-combobox', providers: [
                        OptionSelectionService,
                        { provide: LoadingListener, useExisting: ClrCombobox },
                        IF_ACTIVE_ID_PROVIDER,
                        FOCUS_SERVICE_PROVIDER,
                        COMBOBOX_FOCUS_HANDLER_PROVIDER,
                    ], hostDirectives: [ClrPopoverHostDirective], host: {
                        '[class.aria-required]': 'true',
                        '[class.clr-combobox]': 'true',
                        '[class.clr-combobox-disabled]': 'control?.disabled',
                    }, template: "<!--\n  ~ Copyright (c) 2016-2024 Broadcom. All Rights Reserved.\n  ~ The term \"Broadcom\" refers to Broadcom Inc. and/or its subsidiaries.\n  ~ This software is released under MIT license.\n  ~ The full license information can be found in LICENSE in the root directory of this project.\n-->\n\n<!-- The (click) handler is needed to auto-focus on input field which can not currently occupy the whole\n     width of the component, after being wrapped to a new line -->\n<div\n  class=\"clr-combobox-wrapper\"\n  clrPopoverAnchor\n  (click)=\"focusInput()\"\n  [class.multi]=\"multiSelect\"\n  [class.invalid]=\"invalid\"\n  [class.disabled]=\"control?.disabled? true: null\"\n>\n  <span\n    *ngIf=\"multiSelect && optionSelectionService.selectionModel.model\"\n    role=\"grid\"\n    clrRovingTabindex\n    [clrRovingTabindexDisabled]=\"control?.disabled\"\n    clrDirection=\"both\"\n    [attr.aria-label]=\"getSelectionAriaLabel()\"\n    [attr.aria-disabled]=\"control?.disabled? true: null\"\n  >\n    <span *ngFor=\"let item of multiSelectModel; let i = index\" class=\"label label-combobox-pill\" role=\"row\">\n      <span role=\"gridcell\">\n        <span class=\"clr-combobox-pill-content\" clrKeyFocusItem>\n          <ng-container\n            *ngIf=\"optionSelected\"\n            [ngTemplateOutlet]=\"optionSelected.template\"\n            [ngTemplateOutletContext]=\"{$implicit: optionSelectionService.selectionModel.model[i]}\"\n          ></ng-container>\n        </span>\n      </span>\n      <span role=\"gridcell\">\n        <button\n          clrKeyFocusItem\n          type=\"button\"\n          class=\"clr-combobox-remove-btn\"\n          [disabled]=\"control?.disabled? true: null\"\n          [attr.aria-label]=\"commonStrings.keys.comboboxDelete + ' ' + optionSelectionService.selectionModel.toString(displayField, i)\"\n          (click)=\"unselect(item)\"\n        >\n          <cds-icon shape=\"window-close\" size=\"12\"></cds-icon>\n        </button>\n      </span>\n    </span>\n  </span>\n\n  <span class=\"clr-combobox-input-wrapper\">\n    <input\n      #textboxInput\n      type=\"text\"\n      role=\"combobox\"\n      [id]=\"inputId()\"\n      class=\"clr-input clr-combobox-input\"\n      [(ngModel)]=\"searchText\"\n      (blur)=\"onBlur()\"\n      (focus)=\"onFocus()\"\n      [attr.aria-expanded]=\"openState\"\n      [attr.aria-owns]=\"ariaOwns\"\n      aria-haspopup=\"listbox\"\n      aria-autocomplete=\"list\"\n      autocomplete=\"off\"\n      [attr.aria-invalid]=\"control?.invalid? true: null\"\n      [disabled]=\"control?.disabled? true: null\"\n      [attr.aria-activedescendant]=\"getActiveDescendant()\"\n      [attr.placeholder]=\"placeholder\"\n    />\n  </span>\n\n  <!-- No click handler, as it uses the handler on the .clr-combobox-wrapper -->\n  <button\n    clrPopoverOpenCloseButton\n    #trigger\n    type=\"button\"\n    class=\"clr-combobox-trigger\"\n    tabindex=\"-1\"\n    [disabled]=\"control?.disabled || null\"\n    [attr.aria-label]=\"commonStrings.keys.comboboxOpen\"\n  >\n    <cds-icon shape=\"angle\" direction=\"down\"></cds-icon>\n  </button>\n\n  <div class=\"clr-focus-indicator\" [class.clr-focus]=\"focused\"></div>\n</div>\n\n<!-- Both close handlers are handled manually due to issues in Edge browser.\n     Additionally 'outsideClickToClose' has complex handling that's necessary\n     to be manual due to the component architecture -->\n<div role=\"dialog\" *clrPopoverContent=\"openState at smartPosition; outsideClickToClose: false; scrollToClose: false\">\n  <ng-content></ng-content>\n</div>\n" }]
        }], ctorParameters: function () { return [{ type: i0.ViewContainerRef }, { type: i0.Injector }, { type: i1.NgControl, decorators: [{
                    type: Self
                }, {
                    type: Optional
                }] }, { type: i0.Renderer2 }, { type: i0.ElementRef }, { type: i2.OptionSelectionService }, { type: i3.ClrCommonStringsService }, { type: i4.ClrPopoverToggleService }, { type: i5.ClrPopoverPositionService }, { type: i6.IfControlStateService, decorators: [{
                    type: Optional
                }] }, { type: i7.ComboboxContainerService, decorators: [{
                    type: Optional
                }] }, { type: undefined, decorators: [{
                    type: Inject,
                    args: [PLATFORM_ID]
                }] }, { type: i8.ComboboxFocusHandler }, { type: i0.ChangeDetectorRef }]; }, propDecorators: { placeholder: [{
                type: Input,
                args: ['placeholder']
            }], clrInputChange: [{
                type: Output,
                args: ['clrInputChange']
            }], clrOpenChange: [{
                type: Output,
                args: ['clrOpenChange']
            }], clrSelectionChange: [{
                type: Output,
                args: ['clrSelectionChange']
            }], textbox: [{
                type: ViewChild,
                args: ['textboxInput']
            }], trigger: [{
                type: ViewChild,
                args: ['trigger']
            }], optionSelected: [{
                type: ContentChild,
                args: [ClrOptionSelected]
            }], options: [{
                type: ContentChild,
                args: [ClrOptions]
            }], multiSelect: [{
                type: Input,
                args: ['clrMulti']
            }], onKeyUp: [{
                type: HostListener,
                args: ['keydown', ['$event']]
            }] } });
//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiY29tYm9ib3guanMiLCJzb3VyY2VSb290IjoiIiwic291cmNlcyI6WyIuLi8uLi8uLi8uLi8uLi9wcm9qZWN0cy9hbmd1bGFyL3NyYy9mb3Jtcy9jb21ib2JveC9jb21ib2JveC50cyIsIi4uLy4uLy4uLy4uLy4uL3Byb2plY3RzL2FuZ3VsYXIvc3JjL2Zvcm1zL2NvbWJvYm94L2NvbWJvYm94Lmh0bWwiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7Ozs7O0dBS0c7QUFFSCxPQUFPLEVBQUUsaUJBQWlCLEVBQUUsTUFBTSxpQkFBaUIsQ0FBQztBQUNwRCxPQUFPLEVBR0wsU0FBUyxFQUNULFlBQVksRUFFWixZQUFZLEVBQ1osWUFBWSxFQUNaLE1BQU0sRUFFTixLQUFLLEVBQ0wsUUFBUSxFQUNSLE1BQU0sRUFDTixXQUFXLEVBRVgsSUFBSSxFQUNKLFNBQVMsR0FFVixNQUFNLGVBQWUsQ0FBQztBQUd2QixPQUFPLEVBQUUscUJBQXFCLEVBQUUsTUFBTSwyQ0FBMkMsQ0FBQztBQUNsRixPQUFPLEVBQUUsSUFBSSxFQUFFLE1BQU0sNkJBQTZCLENBQUM7QUFDbkQsT0FBTyxFQUFFLHNCQUFzQixFQUFFLE1BQU0saUNBQWlDLENBQUM7QUFFekUsT0FBTyxFQUFFLGVBQWUsRUFBRSxNQUFNLDZCQUE2QixDQUFDO0FBQzlELE9BQU8sRUFBRSxlQUFlLEVBQUUsTUFBTSxzQ0FBc0MsQ0FBQztBQUN2RSxPQUFPLEVBQUUsWUFBWSxFQUFFLE1BQU0sMENBQTBDLENBQUM7QUFDeEUsT0FBTyxFQUFFLE9BQU8sRUFBRSxNQUFNLHFDQUFxQyxDQUFDO0FBQzlELE9BQU8sRUFBRSxPQUFPLEVBQUUsTUFBTSxxQ0FBcUMsQ0FBQztBQUU5RCxPQUFPLEVBQUUsdUJBQXVCLEVBQUUsTUFBTSw0Q0FBNEMsQ0FBQztBQUdyRixPQUFPLEVBQUUsYUFBYSxFQUF5QixNQUFNLHFEQUFxRCxDQUFDO0FBQzNHLE9BQU8sRUFBRSxrQkFBa0IsRUFBRSxNQUFNLDJCQUEyQixDQUFDO0FB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QyxTQUFTO2dCQUNhLGNBQWM7c0JBQTlDLFlBQVk7dUJBQUMsaUJBQWlCO2dCQWVHLE9BQU87c0JBQXhDLFlBQVk7dUJBQUMsVUFBVTtnQkFrQ3BCLFdBQVc7c0JBRGQsS0FBSzt1QkFBQyxVQUFVO2dCQTZGakIsT0FBTztzQkFETixZQUFZO3VCQUFDLFNBQVMsRUFBRSxDQUFDLFFBQVEsQ0FBQyIsInNvdXJjZXNDb250ZW50IjpbIi8qXG4gKiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAyNCBCcm9hZGNvbS4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAqIFRoZSB0ZXJtIFwiQnJvYWRjb21cIiByZWZlcnMgdG8gQnJvYWRjb20gSW5jLiBhbmQvb3IgaXRzIHN1YnNpZGlhcmllcy5cbiAqIFRoaXMgc29mdHdhcmUgaXMgcmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UuXG4gKiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4gKi9cblxuaW1wb3J0IHsgaXNQbGF0Zm9ybUJyb3dzZXIgfSBmcm9tICdAYW5ndWxhci9jb21tb24nO1xuaW1wb3J0IHtcbiAgQWZ0ZXJDb250ZW50SW5pdCxcbiAgQ2hhbmdlRGV0ZWN0b3JSZWYsXG4gIENvbXBvbmVudCxcbiAgQ29udGVudENoaWxkLFxuICBFbGVtZW50UmVmLFxuICBFdmVudEVtaXR0ZXIsXG4gIEhvc3RMaXN0ZW5lcixcbiAgSW5qZWN0LFxuICBJbmplY3RvcixcbiAgSW5wdXQsXG4gIE9wdGlvbmFsLFxuICBPdXRwdXQsXG4gIFBMQVRGT1JNX0lELFxuICBSZW5kZXJlcjIsXG4gIFNlbGYsXG4gIFZpZXdDaGlsZCxcbiAgVmlld0NvbnRhaW5lclJlZixcbn0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5pbXBvcnQgeyBDb250cm9sVmFsdWVBY2Nlc3NvciwgTmdDb250cm9sIH0gZnJvbSAnQGFuZ3VsYXIvZm9ybXMnO1xuXG5pbXBvcnQgeyBJRl9BQ1RJVkVfSURfUFJPVklERVIgfSBmcm9tICcuLi8uLi91dGlscy9jb25kaXRpb25hbC9pZi1hY3RpdmUuc2VydmljZSc7XG5pbXBvcnQgeyBLZXlzIH0gZnJvbSAnLi4vLi4vdXRpbHMvZW51bXMva2V5cy5lbnVtJztcbmltcG9ydCB7IEZPQ1VTX1NFUlZJQ0VfUFJPVklERVIgfSBmcm9tICcuLi8uLi91dGlscy9mb2N1cy9mb2N1cy5zZXJ2aWNlJztcbmltcG9ydCB7IENsckNvbW1vblN0cmluZ3NTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvaTE4bi9jb21tb24tc3RyaW5ncy5zZXJ2aWNlJztcbmltcG9ydCB7IENsckxvYWRpbmdTdGF0ZSB9IGZyb20gJy4uLy4uL3V0aWxzL2xvYWRpbmcvbG9hZGluZyc7XG5pbXBvcnQgeyBMb2FkaW5nTGlzdGVuZXIgfSBmcm9tICcuLi8uLi91dGlscy9sb2FkaW5nL2xvYWRpbmctbGlzdGVuZXInO1xuaW1wb3J0IHsgQ2xyQWxpZ25tZW50IH0gZnJvbSAnLi4vLi4vdXRpbHMvcG9wb3Zlci9lbnVtcy9hbGlnbm1lbnQuZW51bSc7XG5pbXBvcnQgeyBDbHJBeGlzIH0gZnJvbSAnLi4vLi4vdXRpbHMvcG9wb3Zlci9lbnVtcy9heGlzLmVudW0nO1xuaW1wb3J0IHsgQ2xyU2lkZSB9IGZyb20gJy4uLy4uL3V0aWxzL3BvcG92ZXIvZW51bXMvc2lkZS5lbnVtJztcbmltcG9ydCB7IENsclBvcG92ZXJQb3NpdGlvbiB9IGZyb20gJy4uLy4uL3V0aWxzL3BvcG92ZXIvaW50ZXJmYWNlcy9wb3BvdmVyLXBvc2l0aW9uLmludGVyZmFjZSc7XG5pbXBvcnQgeyBDbHJQb3BvdmVySG9zdERpcmVjdGl2ZSB9IGZyb20gJy4uLy4uL3V0aWxzL3BvcG92ZXIvcG9wb3Zlci1ob3N0LmRpcmVjdGl2ZSc7XG5pbXBvcnQgeyBDbHJQb3BvdmVyUG9zaXRpb25TZXJ2aWNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvcG9wb3Zlci9wcm92aWRlcnMvcG9wb3Zlci1wb3NpdGlvbi5zZXJ2aWNlJztcbmltcG9ydCB7IENsclBvcG92ZXJUb2dnbGVTZXJ2aWNlIH0gZnJvbSAnLi4vLi4vdXRpbHMvcG9wb3Zlci9wcm92aWRlcnMvcG9wb3Zlci10b2dnbGUuc2VydmljZSc7XG5pbXBvcnQgeyBDT05UUk9MX1NUQVRFLCBJZkNvbnRyb2xTdGF0ZVNlcnZpY2UgfSBmcm9tICcuLi9jb21tb24vaWYtY29udHJvbC1zdGF0ZS9pZi1jb250cm9sLXN0YXRlLnNlcnZpY2UnO1xuaW1wb3J0IHsgV3JhcHBlZEZvcm1Db250cm9sIH0gZnJvbSAnLi4vY29tbW9uL3dyYXBwZWQtY29udHJvbCc7XG5pbXBvcnQgeyBDbHJDb21ib2JveENvbnRhaW5lciB9IGZyb20gJy4vY29tYm9ib3gtY29udGFpbmVyJztcbmltcG9ydCB7IENvbWJvYm94TW9kZWwgfSBmcm9tICcuL21vZGVsL2NvbWJvYm94Lm1vZGVsJztcbmltcG9ydCB7IE11bHRpU2VsZWN0Q29tYm9ib3hNb2RlbCB9IGZyb20gJy4vbW9kZWwvbXVsdGktc2VsZWN0LWNvbWJvYm94Lm1vZGVsJztcbmltcG9ydCB7IFNpbmdsZVNlbGVjdENvbWJvYm94TW9kZWwgfSBmcm9tICcuL21vZGVsL3NpbmdsZS1zZWxlY3QtY29tYm9ib3gubW9kZWwnO1xuaW1wb3J0IHsgQ2xyT3B0aW9uU2VsZWN0ZWQgfSBmcm9tICcuL29wdGlvbi1zZWxlY3RlZC5kaXJlY3RpdmUnO1xuaW1wb3J0IHsgQ2xyT3B0aW9ucyB9IGZyb20gJy4vb3B0aW9ucyc7XG5pbXBvcnQgeyBDb21ib2JveENvbnRhaW5lclNlcnZpY2UgfSBmcm9tICcuL3Byb3ZpZGVycy9jb21ib2JveC1jb250YWluZXIuc2VydmljZSc7XG5pbXBvcnQgeyBDT01CT0JPWF9GT0NVU19IQU5ETEVSX1BST1ZJREVSLCBDb21ib2JveEZvY3VzSGFuZGxlciB9IGZyb20gJy4vcHJvdmlkZXJzL2NvbWJvYm94LWZvY3VzLWhhbmRsZXIuc2VydmljZSc7XG5pbXBvcnQgeyBPcHRpb25TZWxlY3Rpb25TZXJ2aWNlIH0gZnJvbSAnLi9wcm92aWRlcnMvb3B0aW9uLXNlbGVjdGlvbi5zZXJ2aWNlJztcblxuQENvbXBvbmVudCh7XG4gIHNlbGVjdG9yOiAnY2xyLWNvbWJvYm94JyxcbiAgdGVtcGxhdGVVcmw6ICcuL2NvbWJvYm94Lmh0bWwnLFxuICBwcm92aWRlcnM6IFtcbiAgICBPcHRpb25TZWxlY3Rpb25TZXJ2aWNlLFxuICAgIHsgcHJvdmlkZTogTG9hZGluZ0xpc3RlbmVyLCB1c2VFeGlzdGluZzogQ2xyQ29tYm9ib3ggfSxcbiAgICBJRl9BQ1RJVkVfSURfUFJPVklERVIsXG4gICAgRk9DVVNfU0VSVklDRV9QUk9WSURFUixcbiAgICBDT01CT0JPWF9GT0NVU19IQU5ETEVSX1BST1ZJREVSLFxuICBdLFxuICBob3N0RGlyZWN0aXZlczogW0NsclBvcG92ZXJIb3N0RGlyZWN0aXZlXSxcbiAgaG9zdDoge1xuICAgICdbY2xhc3MuYXJpYS1yZXF1aXJlZF0nOiAndHJ1ZScsXG4gICAgJ1tjbGFzcy5jbHItY29tYm9ib3hdJzogJ3RydWUnLFxuICAgICdbY2xhc3MuY2xyLWNvbWJvYm94LWRpc2FibGVkXSc6ICdjb250cm9sPy5kaXNhYmxlZCcsXG4gIH0sXG59KVxuZXhwb3J0IGNsYXNzIENsckNvbWJvYm94PFQ+XG4gIGV4dGVuZHMgV3JhcHBlZEZvcm1Db250cm9sPENsckNvbWJvYm94Q29udGFpbmVyPlxuICBpbXBsZW1lbnRzIENvbnRyb2xWYWx1ZUFjY2Vzc29yLCBMb2FkaW5nTGlzdGVuZXIsIEFmdGVyQ29udGVudEluaXRcbntcbiAgQElucHV0KCdwbGFjZWhvbGRlcicpIHBsYWNlaG9sZGVyID0gJyc7XG5cbiAgQE91dHB1dCgnY2xySW5wdXRDaGFuZ2UnKSBjbHJJbnB1dENoYW5nZSA9IG5ldyBFdmVudEVtaXR0ZXI8c3RyaW5nPihmYWxzZSk7XG4gIEBPdXRwdXQoJ2Nsck9wZW5DaGFuZ2UnKSBjbHJPcGVuQ2hhbmdlID0gdGhpcy50b2dnbGVTZXJ2aWNlLm9wZW5DaGFuZ2U7XG5cbiAgLyoqXG4gICAqIFRoaXMgb3V0cHV0IHNob3VsZCBiZSB1c2VkIHRvIHNldCB1cCBhIGxpdmUgcmVnaW9uIHVzaW5nIGFyaWEtbGl2ZSBhbmQgcG9wdWxhdGUgaXQgd2l0aCB1cGRhdGVzIHRoYXQgcmVmbGVjdCBlYWNoIGNvbWJvYm94IGNoYW5nZS5cbiAgICovXG4gIEBPdXRwdXQoJ2NsclNlbGVjdGlvbkNoYW5nZScpIGNsclNlbGVjdGlvbkNoYW5nZSA9IHRoaXMub3B0aW9uU2VsZWN0aW9uU2VydmljZS5zZWxlY3Rpb25DaGFuZ2VkO1xuXG4gIEBWaWV3Q2hpbGQoJ3RleHRib3hJbnB1dCcpIHRleHRib3g6IEVsZW1lbnRSZWY8SFRNTElucHV0RWxlbWVudD47XG4gIEBWaWV3Q2hpbGQoJ3RyaWdnZXInKSB0cmlnZ2VyOiBFbGVtZW50UmVmPEhUTUxCdXR0b25FbGVtZW50PjtcbiAgQENvbnRlbnRDaGlsZChDbHJPcHRpb25TZWxlY3RlZCkgb3B0aW9uU2VsZWN0ZWQ6IENsck9wdGlvblNlbGVjdGVkPFQ+O1xuXG4gIGludmFsaWQgPSBmYWxzZTtcbiAgZm9jdXNlZCA9IGZhbHNlO1xuICBmb2N1c2VkUGlsbDogYW55O1xuXG4gIHNtYXJ0UG9zaXRpb246IENsclBvcG92ZXJQb3NpdGlvbiA9IHtcbiAgICBheGlzOiBDbHJBeGlzLlZFUlRJQ0FMLFxuICAgIHNpZGU6IENsclNpZGUuQUZURVIsXG4gICAgYW5jaG9yOiBDbHJBbGlnbm1lbnQuU1RBUlQsXG4gICAgY29udGVudDogQ2xyQWxpZ25tZW50LlNUQVJULFxuICB9O1xuXG4gIHByb3RlY3RlZCBvdmVycmlkZSBpbmRleCA9IDE7XG5cbiAgQENvbnRlbnRDaGlsZChDbHJPcHRpb25zKSBwcml2YXRlIG9wdGlvbnM6IENsck9wdGlvbnM8VD47XG5cbiAgcHJpdmF0ZSBfc2VhcmNoVGV4dCA9ICcnO1xuICBwcml2YXRlIG9uVG91Y2hlZENhbGxiYWNrOiAoKSA9PiBhbnk7XG4gIHByaXZhdGUgb25DaGFuZ2VDYWxsYmFjazogKG1vZGVsOiBUIHwgVFtdKSA9PiBhbnk7XG5cbiAgY29uc3RydWN0b3IoXG4gICAgdmNyOiBWaWV3Q29udGFpbmVyUmVmLFxuICAgIGluamVjdG9yOiBJbmplY3RvcixcbiAgICBAU2VsZigpXG4gICAgQE9wdGlvbmFsKClcbiAgICBwdWJsaWMgY29udHJvbDogTmdDb250cm9sLFxuICAgIHByb3RlY3RlZCBvdmVycmlkZSByZW5kZXJlcjogUmVuZGVyZXIyLFxuICAgIHByb3RlY3RlZCBvdmVycmlkZSBlbDogRWxlbWVudFJlZjxIVE1MRWxlbWVudD4sXG4gICAgcHVibGljIG9wdGlvblNlbGVjdGlvblNlcnZpY2U6IE9wdGlvblNlbGVjdGlvblNlcnZpY2U8VD4sXG4gICAgcHVibGljIGNvbW1vblN0cmluZ3M6IENsckNvbW1vblN0cmluZ3NTZXJ2aWNlLFxuICAgIHByaXZhdGUgdG9nZ2xlU2VydmljZTogQ2xyUG9wb3ZlclRvZ2dsZVNlcnZpY2UsXG4gICAgcHJpdmF0ZSBwb3NpdGlvblNlcnZpY2U6IENsclBvcG92ZXJQb3NpdGlvblNlcnZpY2UsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBjb250cm9sU3RhdGVTZXJ2aWNlOiBJZkNvbnRyb2xTdGF0ZVNlcnZpY2UsXG4gICAgQE9wdGlvbmFsKCkgcHJpdmF0ZSBjb250YWluZXJTZXJ2aWNlOiBDb21ib2JveENvbnRhaW5lclNlcnZpY2UsXG4gICAgQEluamVjdChQTEFURk9STV9JRCkgcHJpdmF0ZSBwbGF0Zm9ybUlkOiBhbnksXG4gICAgcHJpdmF0ZSBmb2N1c0hhbmRsZXI6IENvbWJvYm94Rm9jdXNIYW5kbGVyPFQ+LFxuICAgIHByaXZhdGUgY2RyOiBDaGFuZ2VEZXRlY3RvclJlZlxuICApIHtcbiAgICBzdXBlcih2Y3IsIENsckNvbWJvYm94Q29udGFpbmVyLCBpbmplY3RvciwgY29udHJvbCwgcmVuZGVyZXIsIGVsKTtcbiAgICBpZiAoY29udHJvbCkge1xuICAgICAgY29udHJvbC52YWx1ZUFjY2Vzc29yID0gdGhpcztcbiAgICB9XG4gICAgLy8gZGVmYXVsdCB0byBTaW5nbGVTZWxlY3RDb21ib2JveE1vZGVsLCBpbiBjYXNlIHRoZSBvcHRpb25hbCBpbnB1dCBbQ2xyTXVsdGldIGlzbid0IHVzZWRcbiAgICBvcHRpb25TZWxlY3Rpb25TZXJ2aWNlLnNlbGVjdGlvbk1vZGVsID0gbmV3IFNpbmdsZVNlbGVjdENvbWJvYm94TW9kZWw8VD4oKTtcbiAgICB0aGlzLnVwZGF0ZUNvbnRyb2xWYWx1ZSgpO1xuICB9XG5cbiAgQElucHV0KCdjbHJNdWx0aScpXG4gIGdldCBtdWx0aVNlbGVjdCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25TZWxlY3Rpb25TZXJ2aWNlLm11bHRpc2VsZWN0YWJsZTtcbiAgfVxuICBzZXQgbXVsdGlTZWxlY3QodmFsdWU6IGJvb2xlYW4gfCBzdHJpbmcpIHtcbiAgICBpZiAodmFsdWUpIHtcbiAgICAgIHRoaXMub3B0aW9uU2VsZWN0aW9uU2VydmljZS5zZWxlY3Rpb25Nb2RlbCA9IG5ldyBNdWx0aVNlbGVjdENvbWJvYm94TW9kZWw8VD4oKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaW4gdGhlb3J5LCBzZXR0aW5nIHRoaXMgYWdhaW4gc2hvdWxkIG5vdCBjYXVzZSBlcnJvcnMgZXZlbiB0aG91Z2ggd2UgYWxyZWFkeSBzZXQgaXQgaW4gY29uc3RydWN0b3IsXG4gICAgICAvLyBzaW5jZSB0aGUgaW5pdGlhbCBjYWxsIHRvIHdyaXRlVmFsdWUgKGNhdXNlZCBieSBbbmdNb2RlbF0gaW5wdXQpIHNob3VsZCBoYXBwZW4gYWZ0ZXIgdGhpc1xuICAgICAgdGhpcy5vcHRpb25TZWxlY3Rpb25TZXJ2aWNlLnNlbGVjdGlvbk1vZGVsID0gbmV3IFNpbmdsZVNlbGVjdENvbWJvYm94TW9kZWw8VD4oKTtcbiAgICB9XG4gICAgdGhpcy51cGRhdGVDb250cm9sVmFsdWUoKTtcbiAgfVxuXG4gIC8vIE92ZXJyaWRlIHRoZSBpZCBvZiBXcmFwcGVkRm9ybUNvbnRyb2wsIGFzIHdlIHdhbnQgdG8gbW92ZSBpdCB0byB0aGUgZW1iZWRkZWQgaW5wdXQuXG4gIC8vIE90aGVyd2lzZSB0aGUgbGFiZWwvY29tcG9uZW50IGNvbm5lY3Rpb24gZG9lcyBub3Qgd29yayBhbmQgc2NyZWVuIHJlYWRlcnMgZG8gbm90IHJlYWQgdGhlIGxhYmVsLlxuICBvdmVycmlkZSBnZXQgaWQoKSB7XG4gICAgcmV0dXJuIHRoaXMuY29udHJvbElkU2VydmljZS5pZCArICctY29tYm9ib3gnO1xuICB9XG4gIG92ZXJyaWRlIHNldCBpZChpZDogc3RyaW5nKSB7XG4gICAgc3VwZXIuaWQgPSBpZDtcbiAgfVxuXG4gIGdldCBzZWFyY2hUZXh0KCk6IHN0cmluZyB7XG4gICAgcmV0dXJuIHRoaXMuX3NlYXJjaFRleHQ7XG4gIH1cbiAgc2V0IHNlYXJjaFRleHQodGV4dDogc3RyaW5nKSB7XG4gICAgLy8gaWYgaW5wdXQgdGV4dCBoYXMgY2hhbmdlZCBzaW5jZSBsYXN0IHRpbWUsIGZpcmUgYSBjaGFuZ2UgZXZlbnQgc28gYXBwbGljYXRpb24gY2FuIHJlYWN0IHRvIGl0XG4gICAgaWYgKHRleHQgIT09IHRoaXMuX3NlYXJjaFRleHQpIHtcbiAgICAgIGlmICh0aGlzLnRvZ2dsZVNlcnZpY2Uub3Blbikge1xuICAgICAgICB0aGlzLm9wdGlvblNlbGVjdGlvblNlcnZpY2Uuc2hvd0FsbE9wdGlvbnMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHRoaXMuX3NlYXJjaFRleHQgPSB0ZXh0O1xuICAgICAgdGhpcy5jbHJJbnB1dENoYW5nZS5lbWl0KHRoaXMuc2VhcmNoVGV4dCk7XG4gICAgfVxuICAgIC8vIFdlIG5lZWQgdG8gdHJpZ2dlciB0aGlzIGV2ZW4gaWYgdW5jaGFuZ2VkLCBzbyB0aGUgb3B0aW9uLWl0ZW1zIGRpcmVjdGl2ZSB3aWxsIHVwZGF0ZSBpdHMgbGlzdFxuICAgIC8vIGJhc2VkIG9uIHRoZSBcInNob3dBbGxPcHRpb25zXCIgdmFyaWFibGUgd2hpY2ggbWF5IGhhdmUgY2hhbmdlZCBpbiB0aGUgb3BlbkNoYW5nZSBzdWJzY3JpcHRpb24gYmVsb3cuXG4gICAgLy8gVGhlIG9wdGlvbi1pdGVtcyBkaXJlY3RpdmUgZG9lcyBub3QgbGlzdGVuIHRvIG9wZW5DaGFuZ2UsIGJ1dCBpdCBsaXN0ZW5zIHRvIGN1cnJlbnRJbnB1dCBjaGFuZ2VzLlxuICAgIHRoaXMub3B0aW9uU2VsZWN0aW9uU2VydmljZS5jdXJyZW50SW5wdXQgPSB0aGlzLnNlYXJjaFRleHQ7XG4gIH1cblxuICBnZXQgb3BlblN0YXRlKCk6IGJvb2xlYW4ge1xuICAgIHJldHVybiB0aGlzLnRvZ2dsZVNlcnZpY2Uub3BlbjtcbiAgfVxuXG4gIGdldCBtdWx0aVNlbGVjdE1vZGVsKCk6IFRbXSB7XG4gICAgaWYgKCF0aGlzLm11bHRpU2VsZWN0KSB7XG4gICAgICB0aHJvdyBFcnJvcignbXVsdGlTZWxlY3RNb2RlbCBpcyBub3QgYXZhaWxhYmxlIGluIHNpbmdsZSBzZWxlY3Rpb24gY29udGV4dCcpO1xuICAgIH1cbiAgICByZXR1cm4gKHRoaXMub3B0aW9uU2VsZWN0aW9uU2VydmljZS5zZWxlY3Rpb25Nb2RlbCBhcyBNdWx0aVNlbGVjdENvbWJvYm94TW9kZWw8VD4pLm1vZGVsO1xuICB9XG5cbiAgZ2V0IGFyaWFDb250cm9scygpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnM/Lm9wdGlvbnNJZDtcbiAgfVxuXG4gIGdldCBhcmlhT3ducygpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbnM/Lm9wdGlvbnNJZDtcbiAgfVxuXG4gIGdldCBhcmlhRGVzY3JpYmVkQnlTZWxlY3Rpb24oKTogc3RyaW5nIHtcbiAgICByZXR1cm4gJ3NlbGVjdGlvbi0nICsgdGhpcy5pZDtcbiAgfVxuXG4gIGdldCBkaXNwbGF5RmllbGQoKTogc3RyaW5nIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25TZWxlY3Rpb25TZXJ2aWNlLmRpc3BsYXlGaWVsZDtcbiAgfVxuXG4gIHByaXZhdGUgZ2V0IGRpc2FibGVkKCkge1xuICAgIHJldHVybiB0aGlzLmNvbnRyb2wgJiYgdGhpcy5jb250cm9sLmRpc2FibGVkO1xuICB9XG5cbiAgbmdBZnRlckNvbnRlbnRJbml0KCkge1xuICAgIHRoaXMuaW5pdGlhbGl6ZVN1YnNjcmlwdGlvbnMoKTtcblxuICAgIC8vIEluaXRpYWxpemUgd2l0aCBwcmVzZWxlY3RlZCB2YWx1ZVxuICAgIGlmICghdGhpcy5vcHRpb25TZWxlY3Rpb25TZXJ2aWNlLnNlbGVjdGlvbk1vZGVsLmlzRW1wdHkoKSkge1xuICAgICAgdGhpcy51cGRhdGVJbnB1dFZhbHVlKHRoaXMub3B0aW9uU2VsZWN0aW9uU2VydmljZS5zZWxlY3Rpb25Nb2RlbCk7XG4gICAgfVxuICB9XG5cbiAgbmdBZnRlclZpZXdJbml0KCkge1xuICAgIHRoaXMuZm9jdXNIYW5kbGVyLmNvbXBvbmVudENkUmVmID0gdGhpcy5jZHI7XG4gICAgdGhpcy5mb2N1c0hhbmRsZXIudGV4dElucHV0ID0gdGhpcy50ZXh0Ym94Lm5hdGl2ZUVsZW1lbnQ7XG4gICAgdGhpcy5mb2N1c0hhbmRsZXIudHJpZ2dlciA9IHRoaXMudHJpZ2dlci5uYXRpdmVFbGVtZW50O1xuICAgIC8vIFRoZSB0ZXh0IGlucHV0IGlzIHRoZSBhY3R1YWwgZWxlbWVudCB3ZSBhcmUgd3JhcHBpbmdcbiAgICAvLyBUaGlzIGFzc2lnbm1lbnQgaXMgbmVlZGVkIGJ5IHRoZSB3cmFwcGVyLCBzbyBpdCBjYW4gc2V0XG4gICAgLy8gdGhlIGFyaWEgcHJvcGVydGllcyBvbiB0aGUgaW5wdXQgZWxlbWVudCwgbm90IG9uIHRoZSBjb21wb25lbnQuXG4gICAgdGhpcy5lbCA9IHRoaXMudGV4dGJveDtcbiAgfVxuXG4gIEBIb3N0TGlzdGVuZXIoJ2tleWRvd24nLCBbJyRldmVudCddKVxuICBvbktleVVwKGV2ZW50OiBLZXlib2FyZEV2ZW50KSB7XG4gICAgLy8gaWYgQkFDS1NQQUNFIGluIG11bHRpc2VsZWN0IG1vZGUsIGRlbGV0ZSB0aGUgbGFzdCBwaWxsIGlmIHRleHQgaXMgZW1wdHlcbiAgICBpZiAoZXZlbnQua2V5ID09PSBLZXlzLkJhY2tzcGFjZSAmJiB0aGlzLm11bHRpU2VsZWN0ICYmIHRoaXMuX3NlYXJjaFRleHQubGVuZ3RoID09PSAwKSB7XG4gICAgICBjb25zdCBtdWx0aU1vZGVsOiBUW10gPSB0aGlzLm9wdGlvblNlbGVjdGlvblNlcnZpY2Uuc2VsZWN0aW9uTW9kZWwubW9kZWwgYXMgVFtdO1xuICAgICAgaWYgKG11bHRpTW9kZWwgJiYgbXVsdGlNb2RlbC5sZW5ndGggPiAwKSB7XG4gICAgICAgIGNvbnN0IGxhc3RJdGVtOiBUID0gbXVsdGlNb2RlbFttdWx0aU1vZGVsLmxlbmd0aCAtIDFdO1xuICAgICAgICB0aGlzLmNvbnRyb2wuY29udHJvbC5tYXJrQXNUb3VjaGVkKCk7XG4gICAgICAgIHRoaXMub3B0aW9uU2VsZWN0aW9uU2VydmljZS51bnNlbGVjdChsYXN0SXRlbSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgaW5wdXRJZCgpOiBzdHJpbmcge1xuICAgIHJldHVybiB0aGlzLmNvbnRyb2xJZFNlcnZpY2UuaWQ7XG4gIH1cblxuICBsb2FkaW5nU3RhdGVDaGFuZ2Uoc3RhdGU6IENsckxvYWRpbmdTdGF0ZSk6IHZvaWQge1xuICAgIHRoaXMub3B0aW9uU2VsZWN0aW9uU2VydmljZS5sb2FkaW5nID0gc3RhdGUgPT09IENsckxvYWRpbmdTdGF0ZS5MT0FESU5HO1xuICAgIHRoaXMucG9zaXRpb25TZXJ2aWNlLnJlYWxpZ24oKTtcbiAgICBpZiAoc3RhdGUgIT09IENsckxvYWRpbmdTdGF0ZS5MT0FESU5HICYmIGlzUGxhdGZvcm1Ccm93c2VyKHRoaXMucGxhdGZvcm1JZCkpIHtcbiAgICAgIHRoaXMuZm9jdXNGaXJzdEFjdGl2ZSgpO1xuICAgIH1cbiAgfVxuXG4gIHVuc2VsZWN0KGl0ZW06IFQpIHtcbiAgICBpZiAoIXRoaXMuZGlzYWJsZWQpIHtcbiAgICAgIHRoaXMub3B0aW9uU2VsZWN0aW9uU2VydmljZS51bnNlbGVjdChpdGVtKTtcbiAgICB9XG4gIH1cblxuICBvbkJsdXIoKSB7XG4gICAgdGhpcy5vblRvdWNoZWRDYWxsYmFjaygpO1xuICAgIGlmICh0aGlzLmNvbnRyb2wuY29udHJvbC51cGRhdGVPbiA9PT0gJ2NoYW5nZScgJiYgdGhpcy5jb250cm9sLmNvbnRyb2w/LmVycm9ycz8ucmVxdWlyZWQpIHtcbiAgICAgIHRoaXMudXBkYXRlQ29udHJvbFZhbHVlKCk7XG4gICAgfVxuICAgIGlmICh0aGlzLmNvbnRyb2wuY29udHJvbC51cGRhdGVPbiA9PT0gJ2JsdXInKSB7XG4gICAgICB0aGlzLmNvbnRyb2wuY29udHJvbC51cGRhdGVWYWx1ZUFuZFZhbGlkaXR5KCk7XG4gICAgfVxuICAgIHRoaXMuZm9jdXNlZCA9IGZhbHNlO1xuICB9XG5cbiAgb25Gb2N1cygpIHtcbiAgICB0aGlzLmZvY3VzZWQgPSB0cnVlO1xuXG4gICAgLy8gZml4IGZvciBcImV4cHJlc3Npb24gY2hhbmdlZFwiIGVycm9yIHdoZW4gZm9jdXMgaXMgcmV0dXJuZWQgdG8gYSBjb21ib2JveCBhZnRlciBhIG1vZGFsIGlzIGNsb3NlZFxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS92bXdhcmUtY2xhcml0eS9uZy1jbGFyaXR5L2lzc3Vlcy82NjNcbiAgICB0aGlzLmNkci5kZXRlY3RDaGFuZ2VzKCk7XG4gIH1cblxuICBnZXRTZWxlY3Rpb25BcmlhTGFiZWwoKSB7XG4gICAgaWYgKHRoaXMuY29udGFpbmVyU2VydmljZSAmJiB0aGlzLmNvbnRhaW5lclNlcnZpY2UubGFiZWxUZXh0KSB7XG4gICAgICByZXR1cm4gYCR7dGhpcy5jb250YWluZXJTZXJ2aWNlLmxhYmVsVGV4dH0gJHt0aGlzLmNvbW1vblN0cmluZ3Mua2V5cy5jb21ib2JveFNlbGVjdGlvbn1gO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5jb21tb25TdHJpbmdzLmtleXMuY29tYm9ib3hTZWxlY3Rpb247XG4gIH1cblxuICBmb2N1c0ZpcnN0QWN0aXZlKCkge1xuICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgdGhpcy5mb2N1c0hhbmRsZXIuZm9jdXNGaXJzdEFjdGl2ZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgd3JpdGVWYWx1ZSh2YWx1ZTogVCB8IFRbXSk6IHZvaWQge1xuICAgIHRoaXMub3B0aW9uU2VsZWN0aW9uU2VydmljZS5zZWxlY3Rpb25Nb2RlbC5tb2RlbCA9IHZhbHVlO1xuICAgIHRoaXMudXBkYXRlSW5wdXRWYWx1ZSh0aGlzLm9wdGlvblNlbGVjdGlvblNlcnZpY2Uuc2VsZWN0aW9uTW9kZWwpO1xuICB9XG5cbiAgcmVnaXN0ZXJPblRvdWNoZWQob25Ub3VjaGVkOiBhbnkpOiB2b2lkIHtcbiAgICB0aGlzLm9uVG91Y2hlZENhbGxiYWNrID0gb25Ub3VjaGVkO1xuICB9XG5cbiAgcmVnaXN0ZXJPbkNoYW5nZShvbkNoYW5nZTogYW55KTogdm9pZCB7XG4gICAgdGhpcy5vbkNoYW5nZUNhbGxiYWNrID0gb25DaGFuZ2U7XG4gIH1cblxuICBnZXRBY3RpdmVEZXNjZW5kYW50KCkge1xuICAgIGNvbnN0IG1vZGVsID0gdGhpcy5mb2N1c0hhbmRsZXIucHNldWRvRm9jdXMubW9kZWw7XG4gICAgcmV0dXJuIG1vZGVsID8gbW9kZWwuaWQgOiB0aGlzLm9wdGlvbnM/Lm5vUmVzdWx0c0VsZW1lbnRJZDtcbiAgfVxuXG4gIHNldERpc2FibGVkU3RhdGUoKTogdm9pZCB7XG4gICAgLy8gZG8gbm90aGluZ1xuICB9XG5cbiAgZm9jdXNJbnB1dCgpIHtcbiAgICB0aGlzLmZvY3VzSGFuZGxlci5mb2N1c0lucHV0KCk7XG4gIH1cblxuICBwcml2YXRlIGluaXRpYWxpemVTdWJzY3JpcHRpb25zKCk6IHZvaWQge1xuICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5wdXNoKFxuICAgICAgdGhpcy5vcHRpb25TZWxlY3Rpb25TZXJ2aWNlLnNlbGVjdGlvbkNoYW5nZWQuc3Vic2NyaWJlKChuZXdTZWxlY3Rpb246IENvbWJvYm94TW9kZWw8VD4pID0+IHtcbiAgICAgICAgdGhpcy51cGRhdGVJbnB1dFZhbHVlKG5ld1NlbGVjdGlvbik7XG4gICAgICAgIGlmICh0aGlzLm11bHRpU2VsZWN0KSB7XG4gICAgICAgICAgdGhpcy5wb3NpdGlvblNlcnZpY2UucmVhbGlnbigpO1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5tdWx0aVNlbGVjdCAmJiBuZXdTZWxlY3Rpb24gJiYgIW5ld1NlbGVjdGlvbi5pc0VtcHR5KCkpIHtcbiAgICAgICAgICB0aGlzLnRvZ2dsZVNlcnZpY2Uub3BlbiA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudXBkYXRlQ29udHJvbFZhbHVlKCk7XG4gICAgICB9KVxuICAgICk7XG5cbiAgICB0aGlzLnN1YnNjcmlwdGlvbnMucHVzaChcbiAgICAgIHRoaXMudG9nZ2xlU2VydmljZS5vcGVuQ2hhbmdlLnN1YnNjcmliZShvcGVuID0+IHtcbiAgICAgICAgaWYgKG9wZW4pIHtcbiAgICAgICAgICB0aGlzLmZvY3VzRmlyc3RBY3RpdmUoKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB0aGlzLm9wdGlvblNlbGVjdGlvblNlcnZpY2Uuc2hvd0FsbE9wdGlvbnMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLm11bHRpU2VsZWN0KSB7XG4gICAgICAgICAgdGhpcy5zZWFyY2hUZXh0ID0gJyc7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGhpcy5zZWFyY2hUZXh0ID0gdGhpcy5nZXREaXNwbGF5TmFtZXModGhpcy5vcHRpb25TZWxlY3Rpb25TZXJ2aWNlLnNlbGVjdGlvbk1vZGVsLm1vZGVsKVswXSB8fCAnJztcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuXG4gICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICB0aGlzLnRvZ2dsZVNlcnZpY2UucG9wb3ZlckFsaWduZWQuc3Vic2NyaWJlKHBvcG92ZXJOb2RlID0+IHtcbiAgICAgICAgLy8gV2hlbiB1c2VkIG91dHNpZGUgYSBjb21ib2JveCBjb250YWluZXJcbiAgICAgICAgaWYgKCF0aGlzLmNvbnRhaW5lclNlcnZpY2UpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY29uc3QgcG9wb3ZlcjogSFRNTEVsZW1lbnQgPSBwb3BvdmVyTm9kZSBhcyBIVE1MRWxlbWVudDtcbiAgICAgICAgLy8gVXBkYXRlIHBvc2l0aW9uIGlmIHBvcG92ZXIgaGlkZXMgdGhlIGxhYmVsXG4gICAgICAgIGlmIChwb3BvdmVyLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpLnRvcCA8IHRoaXMuZWwubmF0aXZlRWxlbWVudC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKS50b3ApIHtcbiAgICAgICAgICB0aGlzLnJlbmRlcmVyLnNldFN0eWxlKHBvcG92ZXJOb2RlLCAndG9wJywgYCR7cG9wb3Zlci5vZmZzZXRUb3AgKyB0aGlzLmNvbnRhaW5lclNlcnZpY2UubGFiZWxPZmZzZXR9cHhgKTtcbiAgICAgICAgfVxuICAgICAgfSlcbiAgICApO1xuXG4gICAgaWYgKHRoaXMuY29udHJvbFN0YXRlU2VydmljZSkge1xuICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLnB1c2goXG4gICAgICAgIHRoaXMuY29udHJvbFN0YXRlU2VydmljZS5zdGF0dXNDaGFuZ2VzLnN1YnNjcmliZShpbnZhbGlkID0+IHtcbiAgICAgICAgICB0aGlzLmludmFsaWQgPSB0aGlzLmNvbnRyb2wuY29udHJvbC50b3VjaGVkICYmIGludmFsaWQgPT09IENPTlRST0xfU1RBVEUuSU5WQUxJRDtcbiAgICAgICAgfSlcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgcHJpdmF0ZSB1cGRhdGVJbnB1dFZhbHVlKG1vZGVsOiBDb21ib2JveE1vZGVsPFQ+KSB7XG4gICAgaWYgKCF0aGlzLm11bHRpU2VsZWN0KSB7XG4gICAgICB0aGlzLnNlYXJjaFRleHQgPSBtb2RlbC5tb2RlbCA/IHRoaXMuZ2V0RGlzcGxheU5hbWVzKG1vZGVsLm1vZGVsKVswXSA6ICcnO1xuICAgICAgaWYgKHRoaXMuc2VhcmNoVGV4dCkge1xuICAgICAgICB0aGlzLm9wdGlvblNlbGVjdGlvblNlcnZpY2UuY3VycmVudElucHV0ID0gdGhpcy5zZWFyY2hUZXh0O1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgdXBkYXRlQ29udHJvbFZhbHVlKCkge1xuICAgIGlmICh0aGlzLm9uQ2hhbmdlQ2FsbGJhY2spIHtcbiAgICAgIHRoaXMub25DaGFuZ2VDYWxsYmFjayh0aGlzLm9wdGlvblNlbGVjdGlvblNlcnZpY2Uuc2VsZWN0aW9uTW9kZWwubW9kZWwpO1xuICAgIH1cbiAgfVxuXG4gIHByaXZhdGUgZ2V0RGlzcGxheU5hbWVzKG1vZGVsOiBUIHwgVFtdKSB7XG4gICAgaWYgKHRoaXMuZGlzcGxheUZpZWxkKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkobW9kZWwpKSB7XG4gICAgICAgIG1vZGVsID0gW21vZGVsXTtcbiAgICAgIH1cbiAgICAgIHJldHVybiBtb2RlbC5tYXAoaXRlbSA9PiAoaXRlbSA/IChpdGVtIGFzIGFueSlbdGhpcy5kaXNwbGF5RmllbGRdIDogbnVsbCkpO1xuICAgIH1cbiAgICByZXR1cm4gW3RoaXMub3B0aW9uU2VsZWN0aW9uU2VydmljZS5zZWxlY3Rpb25Nb2RlbC5tb2RlbF07XG4gIH1cbn1cbiIsIjwhLS1cbiAgfiBDb3B5cmlnaHQgKGMpIDIwMTYtMjAyNCBCcm9hZGNvbS4gQWxsIFJpZ2h0cyBSZXNlcnZlZC5cbiAgfiBUaGUgdGVybSBcIkJyb2FkY29tXCIgcmVmZXJzIHRvIEJyb2FkY29tIEluYy4gYW5kL29yIGl0cyBzdWJzaWRpYXJpZXMuXG4gIH4gVGhpcyBzb2Z0d2FyZSBpcyByZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAgfiBUaGUgZnVsbCBsaWNlbnNlIGluZm9ybWF0aW9uIGNhbiBiZSBmb3VuZCBpbiBMSUNFTlNFIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHByb2plY3QuXG4tLT5cblxuPCEtLSBUaGUgKGNsaWNrKSBoYW5kbGVyIGlzIG5lZWRlZCB0byBhdXRvLWZvY3VzIG9uIGlucHV0IGZpZWxkIHdoaWNoIGNhbiBub3QgY3VycmVudGx5IG9jY3VweSB0aGUgd2hvbGVcbiAgICAgd2lkdGggb2YgdGhlIGNvbXBvbmVudCwgYWZ0ZXIgYmVpbmcgd3JhcHBlZCB0byBhIG5ldyBsaW5lIC0tPlxuPGRpdlxuICBjbGFzcz1cImNsci1jb21ib2JveC13cmFwcGVyXCJcbiAgY2xyUG9wb3ZlckFuY2hvclxuICAoY2xpY2spPVwiZm9jdXNJbnB1dCgpXCJcbiAgW2NsYXNzLm11bHRpXT1cIm11bHRpU2VsZWN0XCJcbiAgW2NsYXNzLmludmFsaWRdPVwiaW52YWxpZFwiXG4gIFtjbGFzcy5kaXNhYmxlZF09XCJjb250cm9sPy5kaXNhYmxlZD8gdHJ1ZTogbnVsbFwiXG4+XG4gIDxzcGFuXG4gICAgKm5nSWY9XCJtdWx0aVNlbGVjdCAmJiBvcHRpb25TZWxlY3Rpb25TZXJ2aWNlLnNlbGVjdGlvbk1vZGVsLm1vZGVsXCJcbiAgICByb2xlPVwiZ3JpZFwiXG4gICAgY2xyUm92aW5nVGFiaW5kZXhcbiAgICBbY2xyUm92aW5nVGFiaW5kZXhEaXNhYmxlZF09XCJjb250cm9sPy5kaXNhYmxlZFwiXG4gICAgY2xyRGlyZWN0aW9uPVwiYm90aFwiXG4gICAgW2F0dHIuYXJpYS1sYWJlbF09XCJnZXRTZWxlY3Rpb25BcmlhTGFiZWwoKVwiXG4gICAgW2F0dHIuYXJpYS1kaXNhYmxlZF09XCJjb250cm9sPy5kaXNhYmxlZD8gdHJ1ZTogbnVsbFwiXG4gID5cbiAgICA8c3BhbiAqbmdGb3I9XCJsZXQgaXRlbSBvZiBtdWx0aVNlbGVjdE1vZGVsOyBsZXQgaSA9IGluZGV4XCIgY2xhc3M9XCJsYWJlbCBsYWJlbC1jb21ib2JveC1waWxsXCIgcm9sZT1cInJvd1wiPlxuICAgICAgPHNwYW4gcm9sZT1cImdyaWRjZWxsXCI+XG4gICAgICAgIDxzcGFuIGNsYXNzPVwiY2xyLWNvbWJvYm94LXBpbGwtY29udGVudFwiIGNscktleUZvY3VzSXRlbT5cbiAgICAgICAgICA8bmctY29udGFpbmVyXG4gICAgICAgICAgICAqbmdJZj1cIm9wdGlvblNlbGVjdGVkXCJcbiAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0XT1cIm9wdGlvblNlbGVjdGVkLnRlbXBsYXRlXCJcbiAgICAgICAgICAgIFtuZ1RlbXBsYXRlT3V0bGV0Q29udGV4dF09XCJ7JGltcGxpY2l0OiBvcHRpb25TZWxlY3Rpb25TZXJ2aWNlLnNlbGVjdGlvbk1vZGVsLm1vZGVsW2ldfVwiXG4gICAgICAgICAgPjwvbmctY29udGFpbmVyPlxuICAgICAgICA8L3NwYW4+XG4gICAgICA8L3NwYW4+XG4gICAgICA8c3BhbiByb2xlPVwiZ3JpZGNlbGxcIj5cbiAgICAgICAgPGJ1dHRvblxuICAgICAgICAgIGNscktleUZvY3VzSXRlbVxuICAgICAgICAgIHR5cGU9XCJidXR0b25cIlxuICAgICAgICAgIGNsYXNzPVwiY2xyLWNvbWJvYm94LXJlbW92ZS1idG5cIlxuICAgICAgICAgIFtkaXNhYmxlZF09XCJjb250cm9sPy5kaXNhYmxlZD8gdHJ1ZTogbnVsbFwiXG4gICAgICAgICAgW2F0dHIuYXJpYS1sYWJlbF09XCJjb21tb25TdHJpbmdzLmtleXMuY29tYm9ib3hEZWxldGUgKyAnICcgKyBvcHRpb25TZWxlY3Rpb25TZXJ2aWNlLnNlbGVjdGlvbk1vZGVsLnRvU3RyaW5nKGRpc3BsYXlGaWVsZCwgaSlcIlxuICAgICAgICAgIChjbGljayk9XCJ1bnNlbGVjdChpdGVtKVwiXG4gICAgICAgID5cbiAgICAgICAgICA8Y2RzLWljb24gc2hhcGU9XCJ3aW5kb3ctY2xvc2VcIiBzaXplPVwiMTJcIj48L2Nkcy1pY29uPlxuICAgICAgICA8L2J1dHRvbj5cbiAgICAgIDwvc3Bhbj5cbiAgICA8L3NwYW4+XG4gIDwvc3Bhbj5cblxuICA8c3BhbiBjbGFzcz1cImNsci1jb21ib2JveC1pbnB1dC13cmFwcGVyXCI+XG4gICAgPGlucHV0XG4gICAgICAjdGV4dGJveElucHV0XG4gICAgICB0eXBlPVwidGV4dFwiXG4gICAgICByb2xlPVwiY29tYm9ib3hcIlxuICAgICAgW2lkXT1cImlucHV0SWQoKVwiXG4gICAgICBjbGFzcz1cImNsci1pbnB1dCBjbHItY29tYm9ib3gtaW5wdXRcIlxuICAgICAgWyhuZ01vZGVsKV09XCJzZWFyY2hUZXh0XCJcbiAgICAgIChibHVyKT1cIm9uQmx1cigpXCJcbiAgICAgIChmb2N1cyk9XCJvbkZvY3VzKClcIlxuICAgICAgW2F0dHIuYXJpYS1leHBhbmRlZF09XCJvcGVuU3RhdGVcIlxuICAgICAgW2F0dHIuYXJpYS1vd25zXT1cImFyaWFPd25zXCJcbiAgICAgIGFyaWEtaGFzcG9wdXA9XCJsaXN0Ym94XCJcbiAgICAgIGFyaWEtYXV0b2NvbXBsZXRlPVwibGlzdFwiXG4gICAgICBhdXRvY29tcGxldGU9XCJvZmZcIlxuICAgICAgW2F0dHIuYXJpYS1pbnZhbGlkXT1cImNvbnRyb2w/LmludmFsaWQ/IHRydWU6IG51bGxcIlxuICAgICAgW2Rpc2FibGVkXT1cImNvbnRyb2w/LmRpc2FibGVkPyB0cnVlOiBudWxsXCJcbiAgICAgIFthdHRyLmFyaWEtYWN0aXZlZGVzY2VuZGFudF09XCJnZXRBY3RpdmVEZXNjZW5kYW50KClcIlxuICAgICAgW2F0dHIucGxhY2Vob2xkZXJdPVwicGxhY2Vob2xkZXJcIlxuICAgIC8+XG4gIDwvc3Bhbj5cblxuICA8IS0tIE5vIGNsaWNrIGhhbmRsZXIsIGFzIGl0IHVzZXMgdGhlIGhhbmRsZXIgb24gdGhlIC5jbHItY29tYm9ib3gtd3JhcHBlciAtLT5cbiAgPGJ1dHRvblxuICAgIGNsclBvcG92ZXJPcGVuQ2xvc2VCdXR0b25cbiAgICAjdHJpZ2dlclxuICAgIHR5cGU9XCJidXR0b25cIlxuICAgIGNsYXNzPVwiY2xyLWNvbWJvYm94LXRyaWdnZXJcIlxuICAgIHRhYmluZGV4PVwiLTFcIlxuICAgIFtkaXNhYmxlZF09XCJjb250cm9sPy5kaXNhYmxlZCB8fCBudWxsXCJcbiAgICBbYXR0ci5hcmlhLWxhYmVsXT1cImNvbW1vblN0cmluZ3Mua2V5cy5jb21ib2JveE9wZW5cIlxuICA+XG4gICAgPGNkcy1pY29uIHNoYXBlPVwiYW5nbGVcIiBkaXJlY3Rpb249XCJkb3duXCI+PC9jZHMtaWNvbj5cbiAgPC9idXR0b24+XG5cbiAgPGRpdiBjbGFzcz1cImNsci1mb2N1cy1pbmRpY2F0b3JcIiBbY2xhc3MuY2xyLWZvY3VzXT1cImZvY3VzZWRcIj48L2Rpdj5cbjwvZGl2PlxuXG48IS0tIEJvdGggY2xvc2UgaGFuZGxlcnMgYXJlIGhhbmRsZWQgbWFudWFsbHkgZHVlIHRvIGlzc3VlcyBpbiBFZGdlIGJyb3dzZXIuXG4gICAgIEFkZGl0aW9uYWxseSAnb3V0c2lkZUNsaWNrVG9DbG9zZScgaGFzIGNvbXBsZXggaGFuZGxpbmcgdGhhdCdzIG5lY2Vzc2FyeVxuICAgICB0byBiZSBtYW51YWwgZHVlIHRvIHRoZSBjb21wb25lbnQgYXJjaGl0ZWN0dXJlIC0tPlxuPGRpdiByb2xlPVwiZGlhbG9nXCIgKmNsclBvcG92ZXJDb250ZW50PVwib3BlblN0YXRlIGF0IHNtYXJ0UG9zaXRpb247IG91dHNpZGVDbGlja1RvQ2xvc2U6IGZhbHNlOyBzY3JvbGxUb0Nsb3NlOiBmYWxzZVwiPlxuICA8bmctY29udGVudD48L25nLWNvbnRlbnQ+XG48L2Rpdj5cbiJdfQ==